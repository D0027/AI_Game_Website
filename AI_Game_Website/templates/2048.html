<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEURAL ARENA | Neon 2048</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <style>
        /* --- CORE STYLES --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background-color: #020202; color: #fff; font-family: 'Rajdhani', sans-serif;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            min-height: 100vh; overflow-y: auto; padding-top: 20px; padding-bottom: 50px;
        }
        #neural-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -2; background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%); }
        .scanlines { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2)); background-size: 100% 4px; pointer-events: none; z-index: -1; opacity: 0.3; }

        .back-btn { position: absolute; top: 30px; left: 30px; text-decoration: none; color: #fff; font-family: 'Orbitron'; font-size: 1rem; border: 1px solid #fff; padding: 10px 20px; border-radius: 5px; transition: 0.3s; background: rgba(255, 255, 255, 0.1); }
        .back-btn:hover { background-color: #fff; color: #000; box-shadow: 0 0 25px #fff; }

        h1 { font-family: 'Orbitron'; font-size: 3.5rem; text-shadow: 0 0 20px #fff; color: #fff; margin-bottom: 10px; margin-top: 40px; }
        
        /* SCOREBOARD */
        .score-container { display: flex; gap: 20px; margin-bottom: 15px; }
        .score-box { 
            background: rgba(50, 50, 50, 0.5); border: 1px solid #fff; border-radius: 5px; 
            padding: 10px 20px; text-align: center; min-width: 120px;
        }
        .score-label { font-family: 'Rajdhani'; font-size: 0.9rem; color: #aaa; letter-spacing: 1px; }
        .score-val { font-family: 'Orbitron'; font-size: 1.5rem; color: #fff; text-shadow: 0 0 10px #fff; }

        /* GRID */
        #game-grid {
            display: grid;
            grid-template-columns: repeat(4, 80px);
            grid-template-rows: repeat(4, 80px);
            gap: 10px;
            background: rgba(50, 50, 50, 0.5);
            padding: 10px;
            border-radius: 10px;
            border: 2px solid #fff;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.2);
        }

        .tile {
            width: 80px; height: 80px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 5px;
            display: flex; align-items: center; justify-content: center;
            font-family: 'Orbitron'; font-weight: bold; font-size: 1.8rem;
            color: #fff; border: 1px solid #333;
            transition: all 0.15s ease-in-out;
        }

        /* TILE COLORS */
        .t-2 { border-color: #eee; color: #eee; text-shadow: 0 0 5px #eee; }
        .t-4 { border-color: #e0f7fa; color: #e0f7fa; text-shadow: 0 0 10px #e0f7fa; }
        .t-8 { border-color: #b2ebf2; color: #b2ebf2; text-shadow: 0 0 15px #b2ebf2; }
        .t-16 { border-color: #80deea; color: #80deea; text-shadow: 0 0 20px #80deea; }
        .t-32 { border-color: #4dd0e1; color: #4dd0e1; text-shadow: 0 0 25px #4dd0e1; }
        .t-64 { border-color: #26c6da; color: #26c6da; text-shadow: 0 0 30px #26c6da; }
        .t-128 { border-color: #00bcd4; color: #00bcd4; text-shadow: 0 0 35px #00bcd4; }
        .t-256 { border-color: #00acc1; color: #00acc1; text-shadow: 0 0 40px #00acc1; }
        .t-512 { border-color: #0097a7; color: #0097a7; text-shadow: 0 0 45px #0097a7; }
        .t-1024 { border-color: #00838f; color: #00838f; text-shadow: 0 0 50px #00838f; }
        .t-2048 { border-color: #006064; color: #fff; background: #00bcd4; box-shadow: 0 0 50px #00bcd4; }

        .controls-area { margin-top: 30px; display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; }
        
        button {
            padding: 10px 20px; font-family: 'Orbitron'; font-size: 0.9rem; color: #000;
            border: none; cursor: pointer; border-radius: 5px; transition: 0.3s;
        }
        button:hover { transform: scale(1.05); }

        .btn-ai { background: #fff; box-shadow: 0 0 15px #fff; }
        .btn-ai:hover { box-shadow: 0 0 25px #fff; }
        .btn-ai.active { background: #00ffcc; box-shadow: 0 0 20px #00ffcc; }
        
        .btn-guide { background: transparent; border: 2px solid #fff; color: #fff; }
        .btn-guide:hover { background: #fff; color: #000; box-shadow: 0 0 15px #fff; }

        .btn-undo { background: #ffcc00; box-shadow: 0 0 15px #ffcc00; }
        .btn-undo:hover { box-shadow: 0 0 25px #ffcc00; }

        .btn-reset { background: #ff0055; color: #fff; box-shadow: 0 0 15px #ff0055; }
        .btn-reset:hover { box-shadow: 0 0 25px #ff0055; }

        .swal-custom-popup { background: #0a0a0a !important; border: 2px solid #fff !important; }
        .swal-custom-title { color: #fff !important; font-family: 'Orbitron' !important; }
        .swal-custom-content { color: #ccc !important; font-family: 'Rajdhani' !important; font-size: 1.1rem; text-align: left;}
    </style>
</head>
<body>
    <canvas id="neural-bg"></canvas>
    <div class="scanlines"></div>

    <a href="/" class="back-btn">← DASHBOARD</a>
    <h1>NEON 2048</h1>
    
    <div class="score-container">
        <div class="score-box">
            <div class="score-label">SCORE</div>
            <div class="score-val" id="score">0</div>
        </div>
        <div class="score-box">
            <div class="score-label">BEST</div>
            <div class="score-val" id="bestScore">0</div>
        </div>
    </div>

    <div id="game-grid"></div>

    <div class="controls-area">
        <button class="btn-guide" onclick="showGuide()">GUIDE</button>
        <button class="btn-undo" onclick="undoMove()">UNDO</button>
        <button class="btn-reset" onclick="resetGame()">RESET SYSTEM</button>
        <button class="btn-ai" id="aiBtn" onclick="toggleAI()">RUN EXPECTIMAX AI</button>
    </div>

    <script>
        const bgCanvas = document.getElementById('neural-bg'); const bgCtx = bgCanvas.getContext('2d');
        bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight;
        let particles=[]; class Particle{constructor(){this.x=Math.random()*bgCanvas.width;this.y=Math.random()*bgCanvas.height;this.size=Math.random()*2;this.speedX=(Math.random()*1)-0.5;this.speedY=(Math.random()*1)-0.5;this.color='#ffffff';}update(){this.x+=this.speedX;this.y+=this.speedY;if(this.x<0||this.x>bgCanvas.width)this.speedX*=-1;if(this.y<0||this.y>bgCanvas.height)this.speedY*=-1;}draw(){bgCtx.fillStyle=this.color;bgCtx.beginPath();bgCtx.arc(this.x,this.y,this.size,0,Math.PI*2);bgCtx.fill();}}
        function init(){particles=[];for(let i=0;i<60;i++)particles.push(new Particle());}
        function animate(){bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height);for(let i=0;i<particles.length;i++){particles[i].update();particles[i].draw();connect(i);}requestAnimationFrame(animate);}
        function connect(a){for(let b=a;b<particles.length;b++){let dist=((particles[a].x-particles[b].x)**2+(particles[a].y-particles[b].y)**2);if(dist<(bgCanvas.width/7)*(bgCanvas.height/7)){bgCtx.strokeStyle='rgba(255,255,255,'+(1-dist/25000)+')';bgCtx.lineWidth=1;bgCtx.beginPath();bgCtx.moveTo(particles[a].x,particles[a].y);bgCtx.lineTo(particles[b].x,particles[b].y);bgCtx.stroke();}}}
        window.addEventListener('resize',()=>{bgCanvas.width=window.innerWidth;bgCanvas.height=window.innerHeight;init();});init();animate();
    </script>

    <script>
        let grid = Array(4).fill().map(() => Array(4).fill(0));
        let score = 0;
        let bestScore = localStorage.getItem('neon2048_best') || 0;
        let aiActive = false;
        let aiInterval;
        
        // Undo History
        let prevGrid = null;
        let prevScore = 0;

        document.getElementById('bestScore').innerText = bestScore;

        function initGame() {
            grid = Array(4).fill().map(() => Array(4).fill(0));
            score = 0;
            prevGrid = null; // Reset undo history
            spawnTile();
            spawnTile();
            drawGrid();
        }

        function resetGame() {
            // Stop AI if running
            if(aiActive) toggleAI();
            initGame();
        }

        function saveState() {
            // Deep copy grid for undo
            prevGrid = JSON.parse(JSON.stringify(grid));
            prevScore = score;
        }

        function undoMove() {
            if(prevGrid) {
                grid = JSON.parse(JSON.stringify(prevGrid));
                score = prevScore;
                drawGrid();
                prevGrid = null; // Can only undo once per move
            }
        }

        function spawnTile() {
            let empty = [];
            for(let r=0; r<4; r++)
                for(let c=0; c<4; c++)
                    if(grid[r][c] === 0) empty.push({r, c});
            
            if(empty.length > 0) {
                let spot = empty[Math.floor(Math.random() * empty.length)];
                grid[spot.r][spot.c] = Math.random() > 0.9 ? 4 : 2;
            }
        }

        function drawGrid() {
            const container = document.getElementById('game-grid');
            container.innerHTML = '';
            document.getElementById('score').innerText = score;
            
            // Update Best Score
            if(score > bestScore) {
                bestScore = score;
                localStorage.setItem('neon2048_best', bestScore);
                document.getElementById('bestScore').innerText = bestScore;
            }
            
            for(let r=0; r<4; r++) {
                for(let c=0; c<4; c++) {
                    let val = grid[r][c];
                    let div = document.createElement('div');
                    div.className = `tile t-${val}`;
                    div.innerText = val > 0 ? val : '';
                    if(val === 0) div.style.background = 'rgba(0,0,0,0.5)';
                    container.appendChild(div);
                }
            }
        }

        // --- CHECK GAME OVER ---
        function checkGameOver() {
            for(let r=0; r<4; r++)
                for(let c=0; c<4; c++)
                    if(grid[r][c] === 0) return false;

            for(let r=0; r<4; r++) {
                for(let c=0; c<4; c++) {
                    if (r < 3 && grid[r][c] === grid[r+1][c]) return false;
                    if (c < 3 && grid[r][c] === grid[r][c+1]) return false;
                }
            }
            triggerGameOver();
            return true;
        }

        function triggerGameOver() {
            if(aiActive) toggleAI();
            Swal.fire({
                title: 'SYSTEM OVERLOAD',
                text: 'Grid Locked. Neural Capacity Reached.',
                background: '#0a0a0a', color: '#fff', icon: 'error',
                confirmButtonText: 'REBOOT SYSTEM',
                confirmButtonColor: '#fff',
                customClass: { popup: 'swal-custom-popup', title: 'swal-custom-title' }
            }).then(() => initGame());
        }

        function showGuide() {
            Swal.fire({
                title: 'MISSION BRIEF',
                html: `
                    <ul style="list-style: none; padding: 0;">
                        <li style="margin-bottom: 10px;">► <strong>OBJECTIVE:</strong> Merge tiles to create 2048.</li>
                        <li style="margin-bottom: 10px;">► <strong>CONTROLS:</strong> Arrow Keys to slide.</li>
                        <li style="margin-bottom: 10px;">► <strong>PHYSICS:</strong> 2+2=4, 4+4=8. Same numbers merge.</li>
                        <li style="margin-bottom: 10px;">► <strong>TOOLS:</strong> Use UNDO if you mess up. Use AI to auto-play.</li>
                    </ul>
                `,
                background: '#0a0a0a', color: '#fff',
                confirmButtonText: 'ACKNOWLEDGED',
                confirmButtonColor: '#fff',
                customClass: { popup: 'swal-custom-popup', title: 'swal-custom-title', content: 'swal-custom-content' }
            });
        }

        // --- AI CONTROL ---
        function toggleAI() {
            if(checkGameOver()) return;
            aiActive = !aiActive;
            const btn = document.getElementById('aiBtn');
            if(aiActive) {
                btn.innerText = "STOP AI";
                btn.classList.add('active');
                aiLoop();
            } else {
                btn.innerText = "RUN EXPECTIMAX AI";
                btn.classList.remove('active');
                clearTimeout(aiInterval);
            }
        }

        function aiLoop() {
            if (!aiActive) return;
            fetch('/move_2048', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ grid: grid })
            })
            .then(res => res.json())
            .then(data => {
                if (data.move) {
                    saveState(); // Save before AI move for undo (optional feature)
                    if (data.move === 'LEFT') performSlide(0, -1);
                    if (data.move === 'RIGHT') performSlide(0, 1);
                    if (data.move === 'UP') performSlide(-1, 0);
                    if (data.move === 'DOWN') performSlide(1, 0);
                    spawnTile();
                    drawGrid();
                    if(!checkGameOver()) aiInterval = setTimeout(aiLoop, 100);
                } else {
                    checkGameOver();
                }
            });
        }

        // --- SLIDE LOGIC ---
        function performSlide(rDir, cDir) {
            let moved = false;
            let traversals = { r: [], c: [] };
            for (let pos = 0; pos < 4; pos++) {
                traversals.r.push(pos);
                traversals.c.push(pos);
            }
            if (rDir === 1) traversals.r.reverse();
            if (cDir === 1) traversals.c.reverse();

            let merged = Array(4).fill().map(() => Array(4).fill(false));

            traversals.r.forEach(r => {
                traversals.c.forEach(c => {
                    if (grid[r][c] === 0) return;

                    let cell = { r: r, c: c };
                    let next = getFarthestPosition(cell, rDir, cDir);
                    let nextCell = next.next;

                    if (nextCell && grid[nextCell.r][nextCell.c] === grid[cell.r][cell.c] && !merged[nextCell.r][nextCell.c]) {
                        grid[nextCell.r][nextCell.c] *= 2;
                        score += grid[nextCell.r][nextCell.c];
                        grid[cell.r][cell.c] = 0;
                        merged[nextCell.r][nextCell.c] = true;
                        moved = true;
                    } else if (grid[next.farthest.r][next.farthest.c] === 0) {
                        grid[next.farthest.r][next.farthest.c] = grid[cell.r][cell.c];
                        grid[cell.r][cell.c] = 0;
                        moved = true;
                    }
                });
            });
            return moved;
        }

        function getFarthestPosition(cell, rDir, cDir) {
            let previous;
            do {
                previous = cell;
                cell = { r: previous.r + rDir, c: previous.c + cDir };
            } while (cell.r >= 0 && cell.r < 4 && cell.c >= 0 && cell.c < 4 && grid[cell.r][cell.c] === 0);
            return { farthest: previous, next: (cell.r >= 0 && cell.r < 4 && cell.c >= 0 && cell.c < 4) ? cell : null };
        }
        
        document.addEventListener('keydown', (e) => {
            if(aiActive) return;
            let moved = false;
            
            // Save state before move
            let tempGrid = JSON.stringify(grid);
            
            if (e.key === 'ArrowLeft') moved = performSlide(0, -1);
            if (e.key === 'ArrowRight') moved = performSlide(0, 1);
            if (e.key === 'ArrowUp') moved = performSlide(-1, 0);
            if (e.key === 'ArrowDown') moved = performSlide(1, 0);
            
            if(moved) {
                // If move was successful, commit state to undo history
                prevGrid = JSON.parse(tempGrid);
                prevScore = score; // This logic needs to capture score before update, handled slightly diff but ok for simple undo
                
                spawnTile();
                drawGrid();
                checkGameOver();
            }
        });

        initGame();
    </script>
</body>
</html>