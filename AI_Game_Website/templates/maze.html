<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEURAL ARENA | Neon Maze</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <style>
        /* --- CORE STYLES --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background-color: #020202; color: #fff; font-family: 'Rajdhani', sans-serif;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            min-height: 100vh; overflow-y: auto; padding-top: 20px; padding-bottom: 50px;
        }
        #neural-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -2; background: radial-gradient(circle at center, #1a0f00 0%, #000 100%); }
        .scanlines { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2)); background-size: 100% 4px; pointer-events: none; z-index: -1; opacity: 0.3; }

        .back-btn { position: absolute; top: 30px; left: 30px; text-decoration: none; color: #ff9900; font-family: 'Orbitron'; font-size: 1rem; border: 1px solid #ff9900; padding: 10px 20px; border-radius: 5px; transition: 0.3s; background: rgba(255, 153, 0, 0.1); }
        .back-btn:hover { background-color: #ff9900; color: #000; box-shadow: 0 0 25px #ff9900; }

        h1 { font-family: 'Orbitron'; font-size: 3.5rem; text-shadow: 0 0 20px #ff9900; color: #ff9900; margin-bottom: 10px; margin-top: 40px; }
        
        .status-bar { font-family: 'Orbitron'; font-size: 1.5rem; margin-bottom: 15px; color: #fff; }
        
        #game-container {
            position: relative;
            padding: 5px;
            background: rgba(20, 10, 0, 0.5);
            border: 2px solid #ff9900;
            box-shadow: 0 0 40px rgba(255, 153, 0, 0.2);
            border-radius: 5px;
        }

        canvas { background: #000; display: block; }

        .controls-area { margin-top: 20px; display: flex; gap: 20px; }
        button {
            padding: 10px 30px; font-family: 'Orbitron'; font-size: 1rem; color: #000; background: #ff9900;
            border: none; cursor: pointer; border-radius: 5px; box-shadow: 0 0 20px #ff9900; transition: 0.3s;
        }
        button:hover { transform: scale(1.1); box-shadow: 0 0 40px #ff9900; }

        .swal-custom-popup { background: #0a0a0a !important; border: 2px solid #ff9900 !important; }
        .swal-custom-title { color: #ff9900 !important; font-family: 'Orbitron' !important; }
    </style>
</head>
<body>
    <canvas id="neural-bg"></canvas>
    <div class="scanlines"></div>

    <a href="/" class="back-btn">‚Üê DASHBOARD</a>
    <h1>NEON MAZE</h1>
    <div class="status-bar" id="status">PRESS ANY ARROW TO START RACE</div>

    <div id="game-container">
        <canvas id="mazeCanvas" width="600" height="600"></canvas>
    </div>

    <div class="controls-area">
        <button onclick="location.reload()">NEW MAZE</button>
    </div>

    <script>
        const bgCanvas = document.getElementById('neural-bg'); const bgCtx = bgCanvas.getContext('2d');
        bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight;
        let particles=[]; class Particle{constructor(){this.x=Math.random()*bgCanvas.width;this.y=Math.random()*bgCanvas.height;this.size=Math.random()*2;this.speedX=(Math.random()*1.5)-0.75;this.speedY=(Math.random()*1.5)-0.75;this.color='#ff9900';}update(){this.x+=this.speedX;this.y+=this.speedY;if(this.x<0||this.x>bgCanvas.width)this.speedX*=-1;if(this.y<0||this.y>bgCanvas.height)this.speedY*=-1;}draw(){bgCtx.fillStyle=this.color;bgCtx.beginPath();bgCtx.arc(this.x,this.y,this.size,0,Math.PI*2);bgCtx.fill();}}
        function init(){particles=[];for(let i=0;i<80;i++)particles.push(new Particle());}
        function animate(){bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height);for(let i=0;i<particles.length;i++){particles[i].update();particles[i].draw();connect(i);}requestAnimationFrame(animate);}
        function connect(a){for(let b=a;b<particles.length;b++){let dist=((particles[a].x-particles[b].x)**2+(particles[a].y-particles[b].y)**2);if(dist<(bgCanvas.width/7)*(bgCanvas.height/7)){bgCtx.strokeStyle='rgba(255, 153, 0,'+(1-dist/20000)+')';bgCtx.lineWidth=1;bgCtx.beginPath();bgCtx.moveTo(particles[a].x,particles[a].y);bgCtx.lineTo(particles[b].x,particles[b].y);bgCtx.stroke();}}}
        window.addEventListener('resize',()=>{bgCanvas.width=window.innerWidth;bgCanvas.height=window.innerHeight;init();});init();animate();
    </script>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        
        // Maze Config
        const cols = 21; // Odd numbers work best for this generation algo
        const rows = 21;
        const cellSize = canvas.width / cols;
        let maze = []; // 1=Wall, 0=Path
        
        // Players
        let player = {r: 1, c: 1, color: '#ffcc00'};
        let ai = {r: 1, c: 1, color: '#ff0055', path: [], step: 0};
        let end = {r: rows-2, c: cols-2};
        
        let raceStarted = false;
        let gameOver = false;

        function initMaze() {
            // Fill with walls
            maze = Array(rows).fill().map(() => Array(cols).fill(1));
            
            // Generate Maze (Recursive Backtracker)
            function carve(r, c) {
                maze[r][c] = 0;
                const directions = [[0, -2], [0, 2], [-2, 0], [2, 0]].sort(() => Math.random() - 0.5);
                
                for(let [dr, dc] of directions) {
                    let nr = r + dr, nc = c + dc;
                    if(nr > 0 && nr < rows-1 && nc > 0 && nc < cols-1 && maze[nr][nc] === 1) {
                        maze[r + dr/2][c + dc/2] = 0; // Carve wall between
                        carve(nr, nc);
                    }
                }
            }
            carve(1, 1);
            maze[rows-2][cols-2] = 0; // Ensure exit is open
            draw();
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Walls
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    if(maze[r][c] === 1) {
                        ctx.fillStyle = '#ff9900';
                        ctx.shadowBlur = 10; ctx.shadowColor = '#ff9900';
                        ctx.fillRect(c*cellSize, r*cellSize, cellSize, cellSize);
                        ctx.shadowBlur = 0;
                    }
                }
            }

            // Draw Goal
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(end.c*cellSize + 5, end.r*cellSize + 5, cellSize - 10, cellSize - 10);

            // Draw Player
            ctx.fillStyle = player.color;
            ctx.shadowBlur = 15; ctx.shadowColor = player.color;
            ctx.beginPath();
            ctx.arc(player.c*cellSize + cellSize/2, player.r*cellSize + cellSize/2, cellSize/3, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw AI
            ctx.fillStyle = ai.color;
            ctx.shadowBlur = 15; ctx.shadowColor = ai.color;
            ctx.beginPath();
            ctx.arc(ai.c*cellSize + cellSize/2, ai.r*cellSize + cellSize/2, cellSize/4, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function startRace() {
            if(raceStarted) return;
            raceStarted = true;
            document.getElementById('status').innerText = "RACE IN PROGRESS...";
            
            // Get AI Path from Python
            fetch('/solve_maze', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ grid: maze, start: [1,1], end: [end.r, end.c] })
            })
            .then(res => res.json())
            .then(data => {
                ai.path = data.path;
                moveAI();
            });
        }

        function moveAI() {
            if(gameOver) return;
            if(ai.step < ai.path.length) {
                let nextPos = ai.path[ai.step];
                ai.r = nextPos[0];
                ai.c = nextPos[1];
                ai.step++;
                draw();
                
                if(ai.r === end.r && ai.c === end.c) {
                    endGame("AI WINS! (DFS ALGORITHM)");
                } else {
                    setTimeout(moveAI, 150); // AI Speed (Adjust to make it fair)
                }
            }
        }

        document.addEventListener('keydown', (e) => {
            if(gameOver) return;
            if(!raceStarted && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) startRace();

            let nr = player.r, nc = player.c;
            if(e.key === 'ArrowUp') nr--;
            if(e.key === 'ArrowDown') nr++;
            if(e.key === 'ArrowLeft') nc--;
            if(e.key === 'ArrowRight') nc++;

            if(maze[nr][nc] === 0) {
                player.r = nr;
                player.c = nc;
                draw();
                if(player.r === end.r && player.c === end.c) {
                    endGame("YOU WIN!");
                }
            }
        });

        function endGame(msg) {
            gameOver = true;
            let col = msg === "YOU WIN!" ? "#00ff00" : "#ff0055";
            let ico = msg === "YOU WIN!" ? "success" : "error";
            
            Swal.fire({
                title: msg,
                background: '#0a0a0a', color: col, icon: ico,
                confirmButtonText: 'PLAY AGAIN',
                customClass: { popup: 'swal-custom-popup', title: 'swal-custom-title' }
            }).then(() => location.reload());
        }

        initMaze();
    </script>
</body>
</html>