<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEURAL ARENA | Neon Tetris</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <style>
        /* --- CORE STYLES --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background-color: #020202; color: #fff; font-family: 'Rajdhani', sans-serif;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            min-height: 100vh; overflow-y: auto; padding-top: 20px; padding-bottom: 50px;
            user-select: none;
        }
        #neural-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -2; background: radial-gradient(circle at center, #140026 0%, #000 100%); }
        .scanlines { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2)); background-size: 100% 4px; pointer-events: none; z-index: -1; opacity: 0.3; }

        .back-btn { position: absolute; top: 30px; left: 30px; text-decoration: none; color: #8a2be2; font-family: 'Orbitron'; font-size: 1rem; border: 1px solid #8a2be2; padding: 10px 20px; border-radius: 5px; transition: 0.3s; background: rgba(138, 43, 226, 0.1); }
        .back-btn:hover { background-color: #8a2be2; color: #000; box-shadow: 0 0 25px #8a2be2; }

        h1 { font-family: 'Orbitron'; font-size: 3.5rem; text-shadow: 0 0 20px #8a2be2; color: #8a2be2; margin-bottom: 10px; margin-top: 40px; }
        
        .game-layout { display: flex; gap: 30px; align-items: flex-start; margin-top: 20px; }
        
        #gameCanvas {
            background: rgba(10, 0, 20, 0.9);
            border: 2px solid #8a2be2;
            box-shadow: 0 0 40px rgba(138, 43, 226, 0.2);
            border-radius: 5px;
        }

        .side-panel { display: flex; flex-direction: column; gap: 20px; }
        .panel-box {
            background: rgba(138, 43, 226, 0.1); border: 1px solid #8a2be2;
            padding: 15px; border-radius: 5px; text-align: center; min-width: 150px;
        }
        .label { font-family: 'Rajdhani'; color: #ccc; font-size: 0.9rem; margin-bottom: 5px; }
        .value { font-family: 'Orbitron'; font-size: 1.5rem; color: #fff; text-shadow: 0 0 10px #8a2be2; }

        .controls-area { margin-top: 20px; display: flex; gap: 20px; }
        button {
            padding: 10px 30px; font-family: 'Orbitron'; font-size: 1rem; color: #000; background: #8a2be2;
            border: none; cursor: pointer; border-radius: 5px; box-shadow: 0 0 20px #8a2be2; transition: 0.3s;
        }
        button:hover { transform: scale(1.1); box-shadow: 0 0 40px #8a2be2; }
        .btn-ai.active { background: #00ffcc; box-shadow: 0 0 20px #00ffcc; }

        .swal-custom-popup { background: #0a0a0a !important; border: 2px solid #8a2be2 !important; }
        .swal-custom-title { color: #8a2be2 !important; font-family: 'Orbitron' !important; }
    </style>
</head>
<body>
    <canvas id="neural-bg"></canvas>
    <div class="scanlines"></div>

    <a href="/" class="back-btn">‚Üê DASHBOARD</a>
    <h1>NEON TETRIS</h1>

    <div class="game-layout">
        <canvas id="gameCanvas" width="300" height="600"></canvas>
        
        <div class="side-panel">
            <div class="panel-box">
                <div class="label">SCORE</div>
                <div class="value" id="score">0</div>
            </div>
            <div class="panel-box">
                <div class="label">LINES</div>
                <div class="value" id="lines">0</div>
            </div>
            <div class="panel-box">
                <div class="label">LEVEL</div>
                <div class="value" id="level">1</div>
            </div>
        </div>
    </div>

    <div class="controls-area">
        <button onclick="resetGame()">RESTART SYSTEM</button>
        <button id="aiBtn" class="btn-ai" onclick="toggleAI()">ACTIVATE AI</button>
    </div>

    <script>
        const bgCanvas = document.getElementById('neural-bg'); const bgCtx = bgCanvas.getContext('2d');
        bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight;
        let bgParticles=[]; class Particle{constructor(){this.x=Math.random()*bgCanvas.width;this.y=Math.random()*bgCanvas.height;this.size=Math.random()*2;this.speedX=(Math.random()*1.5)-0.75;this.speedY=(Math.random()*1.5)-0.75;this.color='#8a2be2';}update(){this.x+=this.speedX;this.y+=this.speedY;if(this.x<0||this.x>bgCanvas.width)this.speedX*=-1;if(this.y<0||this.y>bgCanvas.height)this.speedY*=-1;}draw(){bgCtx.fillStyle=this.color;bgCtx.beginPath();bgCtx.arc(this.x,this.y,this.size,0,Math.PI*2);bgCtx.fill();}}
        function initBg(){bgParticles=[];for(let i=0;i<80;i++)bgParticles.push(new Particle());}
        function animateBg(){bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height);for(let i=0;i<bgParticles.length;i++){bgParticles[i].update();bgParticles[i].draw();connect(i);}requestAnimationFrame(animateBg);}
        function connect(a){for(let b=a;b<bgParticles.length;b++){let dist=((bgParticles[a].x-bgParticles[b].x)**2+(bgParticles[a].y-bgParticles[b].y)**2);if(dist<(bgCanvas.width/7)*(bgCanvas.height/7)){bgCtx.strokeStyle='rgba(138, 43, 226,'+(1-dist/20000)+')';bgCtx.lineWidth=1;bgCtx.beginPath();bgCtx.moveTo(bgParticles[a].x,bgParticles[a].y);bgCtx.lineTo(bgParticles[b].x,bgParticles[b].y);bgCtx.stroke();}}}
        window.addEventListener('resize',()=>{bgCanvas.width=window.innerWidth;bgCanvas.height=window.innerHeight;initBg();});initBg();animateBg();
    </script>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const ROWS = 20;
        const COLS = 10;
        const SQ = 30; // Square size
        const VACANT = "#111"; // Empty color

        // Shapes
        const PIECES = [
            [Z, "#ff0055"], [S, "#00ff00"], [T, "#8a2be2"], [O, "#ffff00"], 
            [L, "#ff9900"], [I, "#00ffff"], [J, "#0000ff"]
        ];

        // Shape Patterns
        function I(){ return [[1,1,1,1]]; }
        function J(){ return [[1,0,0],[1,1,1]]; }
        function L(){ return [[0,0,1],[1,1,1]]; }
        function O(){ return [[1,1],[1,1]]; }
        function S(){ return [[0,1,1],[1,1,0]]; }
        function T(){ return [[0,1,0],[1,1,1]]; }
        function Z(){ return [[1,1,0],[0,1,1]]; }

        let board = [];
        let score = 0;
        let lines = 0;
        let level = 1;
        let gameOver = false;
        let dropStart = Date.now();
        let p; 
        let isAI = false;
        let aiProcessing = false;

        // Init Board
        function createBoard() {
            for(let r=0; r<ROWS; r++){
                board[r] = [];
                for(let c=0; c<COLS; c++){
                    board[r][c] = VACANT;
                }
            }
        }

        function drawSquare(x, y, color){
            ctx.fillStyle = color;
            ctx.fillRect(x*SQ, y*SQ, SQ, SQ);
            ctx.strokeStyle = "#000";
            ctx.strokeRect(x*SQ, y*SQ, SQ, SQ);
            
            // Neon Glow effect
            if(color !== VACANT) {
                ctx.shadowBlur = 15; ctx.shadowColor = color;
                ctx.fillRect(x*SQ+2, y*SQ+2, SQ-4, SQ-4);
                ctx.shadowBlur = 0;
            }
        }

        function drawBoard(){
            for(let r=0; r<ROWS; r++){
                for(let c=0; c<COLS; c++){
                    drawSquare(c, r, board[r][c]);
                }
            }
        }

        class Piece {
            constructor(tetromino, color, typeChar){
                this.tetromino = tetromino;
                this.color = color;
                this.typeChar = typeChar; // For AI
                this.tetrominoN = 0; // Rotation index
                this.activeTetromino = this.tetromino;
                this.x = 3;
                this.y = -2;
            }

            fill(color){
                for(let r=0; r<this.activeTetromino.length; r++){
                    for(let c=0; c<this.activeTetromino[r].length; c++){
                        if(this.activeTetromino[r][c]){
                            drawSquare(this.x + c, this.y + r, color);
                        }
                    }
                }
            }

            draw(){ this.fill(this.color); }
            unDraw(){ this.fill(VACANT); }

            moveDown(){
                if(!this.collision(0, 1, this.activeTetromino)){
                    this.unDraw();
                    this.y++;
                    this.draw();
                } else {
                    this.lock();
                    p = randomPiece();
                }
            }

            moveRight(){
                if(!this.collision(1, 0, this.activeTetromino)){
                    this.unDraw();
                    this.x++;
                    this.draw();
                }
            }

            moveLeft(){
                if(!this.collision(-1, 0, this.activeTetromino)){
                    this.unDraw();
                    this.x--;
                    this.draw();
                }
            }

            rotate(){
                let nextPattern = this.tetromino; // Simple logic: rotate matrix
                // Matrix rotation logic
                let N = this.activeTetromino.length;
                let M = this.activeTetromino[0].length;
                let newMatrix = [];
                for(let i=0; i<M; i++){
                    let newRow = [];
                    for(let j=0; j<N; j++){
                        newRow.push(this.activeTetromino[N-1-j][i]);
                    }
                    newMatrix.push(newRow);
                }
                
                if(!this.collision(0, 0, newMatrix)){
                    this.unDraw();
                    this.activeTetromino = newMatrix;
                    this.tetrominoN = (this.tetrominoN + 1) % 4;
                    this.draw();
                }
            }

            lock(){
                for(let r=0; r<this.activeTetromino.length; r++){
                    for(let c=0; c<this.activeTetromino[r].length; c++){
                        if(!this.activeTetromino[r][c]) continue;
                        if(this.y + r < 0){
                            gameOver = true;
                            Swal.fire({
                                title: "SYSTEM FAILURE",
                                background: '#0a0a0a', color: '#8a2be2', icon: 'error',
                                confirmButtonText: 'REBOOT',
                                customClass: { popup: 'swal-custom-popup', title: 'swal-custom-title' }
                            }).then(() => resetGame());
                            return;
                        }
                        board[this.y+r][this.x+c] = this.color;
                    }
                }
                // Remove full rows
                for(let r=0; r<ROWS; r++){
                    let isRowFull = true;
                    for(let c=0; c<COLS; c++){
                        isRowFull = isRowFull && (board[r][c] != VACANT);
                    }
                    if(isRowFull){
                        for(let y=r; y>1; y--){
                            for(let c=0; c<COLS; c++){
                                board[y][c] = board[y-1][c];
                            }
                        }
                        for(let c=0; c<COLS; c++) board[0][c] = VACANT;
                        score += 10;
                        lines++;
                        document.getElementById('score').innerText = score;
                        document.getElementById('lines').innerText = lines;
                    }
                }
                drawBoard();
            }

            collision(x, y, piece){
                for(let r=0; r<piece.length; r++){
                    for(let c=0; c<piece[r].length; c++){
                        if(!piece[r][c]) continue;
                        let newX = this.x + c + x;
                        let newY = this.y + r + y;
                        if(newX < 0 || newX >= COLS || newY >= ROWS) return true;
                        if(newY < 0) continue;
                        if(board[newY][newX] != VACANT) return true;
                    }
                }
                return false;
            }
        }

        function randomPiece(){
            let r = Math.floor(Math.random() * PIECES.length);
            let charMap = ['Z','S','T','O','L','I','J'];
            return new Piece(PIECES[r][0](), PIECES[r][1], charMap[r]);
        }

        function drop(){
            if(gameOver) return;
            let now = Date.now();
            let delta = now - dropStart;
            let speed = isAI ? 50 : 1000; // AI plays super fast

            if(delta > speed){
                p.moveDown();
                dropStart = Date.now();
                if(isAI && !aiProcessing) runAI();
            }
            if(!gameOver) requestAnimationFrame(drop);
        }

        // --- AI LOGIC ---
        function runAI() {
            aiProcessing = true;
            // Convert board to simple binary grid for Python
            let simpleGrid = board.map(row => row.map(col => col === VACANT ? 0 : 1));
            
            fetch('/solve_tetris', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ 
                    grid: simpleGrid, 
                    piece: p.typeChar 
                })
            })
            .then(res => res.json())
            .then(move => {
                // Execute Rotation
                while(p.tetrominoN !== move.rotation) p.rotate();
                // Execute Move X
                while(p.x < move.x) p.moveRight();
                while(p.x > move.x) p.moveLeft();
                aiProcessing = false;
            });
        }

        function toggleAI() {
            isAI = !isAI;
            const btn = document.getElementById('aiBtn');
            if(isAI) {
                btn.innerText = "DEACTIVATE AI";
                btn.classList.add('active');
            } else {
                btn.innerText = "ACTIVATE AI";
                btn.classList.remove('active');
            }
        }

        // Controls
        document.addEventListener('keydown', (e) => {
            if(isAI) return;
            if(e.key == "ArrowLeft") p.moveLeft();
            else if(e.key == "ArrowUp") p.rotate();
            else if(e.key == "ArrowRight") p.moveRight();
            else if(e.key == "ArrowDown") p.moveDown();
        });

        function resetGame() {
            createBoard();
            drawBoard();
            score = 0; lines = 0;
            document.getElementById('score').innerText = 0;
            document.getElementById('lines').innerText = 0;
            p = randomPiece();
            gameOver = false;
            drop();
        }

        createBoard();
        drawBoard();
        p = randomPiece();
        drop();

    </script>
</body>
</html>